넥스트 13~14의 차이점
- 앱 라우터는 디렉터리 기능이 달라짐
1) 페이지 라우터에서 레이아웃 기능이 없었으나, 앱 라우터는 있음
2) 사용자별 권한 문제도 미들웨어로 지원함으로써 쉬워짐

- 리액트 18를 사용함으로써 서버 컴포넌트를 적극적으로 활용함
1) 넥스트 서버에서 미리 렌더링을 하여 완성된 HTML을 보내줄 수 있어 페이지 로딩 시간을 절감시킴
2) 용량도 줄어듦
3) 넥스트 서버의 부담이 생김 -> 캐시를 적극적으로 활용함 (데이터 캐싱)

- 넥스트는 리액트 위에 돌아가는 프레임 워크로 화면 그리기, 라우팅, 데이터 가져오기, 배포, 최적화와 같은 리액트만 했을 때 따로 추가해야 될 것으로
내부적으로 지원해줌

- 넥스트는 서버 기능도 제공해줌

- npx create-next-app@latest

- public 폴더는 next 서버에서 누구나 접근할 수 있게해 줌
1) 공개할 데이터 이미지 같은 것을 두면 됨

- src 폴더 없이 app 폴더가 밖에 있으나, src/app으로 두는 게 좋음
1) 다른 류의 자바스크립트/타입스크립트 파일이 들어갈 수 있으므로 src 폴더 내 넣는 게 좋음
2) app 폴더는 라우팅 혹은 주소 담당

- next.config.js는 넥스트에 대한 설정

- tsconfig.json는 타입스크립트 기본 설정 파일임

- 페이지를 넘나들어도 바뀌지 않는 부분은 레이아웃에 속함

- not-found.tsx 파일은 어느 라우팅에도 존재하지 않을 때, 접근하는 기본 페이지임

- 계층 구조는 layout.tsx -> 디렉토리 내 layout.tsx -> 디렉토리 내 page.tsx

- [] 디렉토리는 주소 창에서 값이 변하는 애들을 자동으로 매칭시켜주는 역할

- () 디렉토리는 주소 창에 관여하지 않으나, 그룹을 만들 수 있는 역할

- 처음 레이아웃 및 폴더 구조를 잘 구성하는 게 좋음

- 그룹핑 하는 기준이 레이아웃 -> 폴더별로 레이아웃 구성이 가능하므로

- 레이아웃은 페이지 변경되어도 유지되며 리렌더링이 발생되지 않음 -> 페이지만 리렌더링이 발생됨
1) 페이지 변경 시마다 레이아웃도 리렌더링이 되게 하려면 template.tsx를 사용 -> 페이지 넘나들 때마다 기록하는 경우, 예를 들면 구글 애널리틱스임 (리렌더링보다 새로 마운트됨)
2) 페이지 변경 시마다 레이아웃도 리렌더링이 안 되게 하려면 layout.tsx를 사용 -> 보통은 이 파일로 많이 만듦
3) 두 파일은 같은 경로에 둘 수 없으며, 단 하나만 존재해야 함

- 넥스트에서는 Link는 HTML의 a태그를 대체하며 반드시 Link를 사용해야 함
1) Link에 특수한 기능이 있기 때문에 사용 -> a 태그로 생성하면 페이지를 새로고침하면서 페이지 전환이 됨
2) 리액트나 넥스트에선 리렌더링 문제로 인해 새로고침이 발생되면 안 됨

- 넥스트에선 img 대신 Image를 사용하면 자동으로 이미지를 최적화해 줌
1) 공식 문서 내 Optimizing Images 항목 참조

- CSS 모듈로 하기 모듈을 많이 사용함
1) tailwind : 호불호 심하고 가독성 안 좋음
2) Styled Component or Emotion : Styled Component는 서버 컴포넌트에서 SSR 문제 존재, Emotion은 Next 13에서 잘 동작 안 됨
3) sass
4) css module : 간단하게 하기 위해 실습에서 이걸 사용 -> styles로 임포트 가능,
  = 다른 파일이랑 겹쳐도 page."module".css처럼 module이 들어가므로 겹치는 일이 없음, 이름이 동일해도 각 페이지별 클래스 이름을 구별해 줌
5) vanilla extract : windows와 문제가 존재, 다른 부분에선 문제점이 없음, 얘가 요즈음 핫함

- dvh, dvw는 모바일에서도 주소창 유무에 상관없이 전체화면을 채울 수 있음

- 패러렐 라우트나 인터셉트 라우터를 활용하면 페이지를 이동하지 않고, 주소만 변경할 수 있음

- 앱 라우터에선 폴더로 디렉토리 구조를 바꿀 수 있음

- 패러렐 라우터는 동시에 여러 페이지를 보여주는 라우트
1) 같은 폴더 내 page.tsx 파일이 존재해야지만, 페러렐 라우터가 동작됨
    -> (beforeLogin) 내 @modal/page.tsx와 page.tsx (O)
    -> (beforeLogin) 내 @modal/page.tsx와 app/page.tsx (X)
2) layout.tsx 파일도 같은 폴더 내에도 존재해야 됨
    -> 한 화면에서 두 페이지를 동시에 보여주므로 = 해당 파일은 app에서 (beforeLogin)으로 옮길 필요는 없음

- 타입스크립트는 변수, 매개변수, 리턴값에 타입을 지정하는 것임

- 넥스트 내 모든 컴포넌트는 기본적으로 전부 서버 컴포넌트임
1) page.tsx, layout.tsx 등의 파일은 전부 nextjs 서버에서 동작함
2) 리액트 18에서 추가된 기능임
3) 브라우저가 아닌 서버에서 동작함
4) 비동기이므로, async를 통한 비동기 처리 가능
5) use를 사용하는 훅스들을 사용할 수 없음
6) 서버 컴포넌트는 전부 데이터와 연관이 있음

- "use client" 키워드를 사용하면 서버 컴포넌트를 클라이언트 컴포넌트로 변경이 가능함
1) use strict를 본따서 만든 듯함

- default.tsx는 패러렐 라우트의 기본값으로, 페러렐 라우트를 사용할 필요가 없을 때 사용하는 기본 값 파일

- 인터셉팅 라우트는 서로 주소가 달라도 같은 화면에 뜰 수 있도록 만든 라우트
1) Link를 통한 상황에서는 인터셉팅 라우트로 인한 주소로 이동되나 새로 고침을 하면 기존 주소로 이동됨

- 프라이빗 폴더는 중복된 내용을 가진 파일들을 하나의 공통으로 묶을 수 있음 (_component)

- 주소 창에 영향이 없는 폴더 4가지
1) 그룹 폴더( () )는 레이아웃를 두는 것
2) 패러렐 라우트 (@)는 한 화면에 두 개의 페이지를 동시에 보여주는 것
3) 인터셉트 라우트 ((..))는 Link로 이동했을 때 가로채어 다른 경로로 이동시켜줌 (새로고침 시 해당 페이지로 이동)
4) 프라이빗 폴더 (_)는 폴더 정리용

- 서버 컴포넌트는 클라이언트 컴포넌트를 임포트해도 되나, 클라이언트 컴포넌트는 서버 컴포넌트를 임포트하면 안 됨
1) 가능은 하나, 임포트하면 서버 컴포넌트가 클라이언트 컴포넌트로 바뀜
2) 원칙적으론 서버 컴포넌트만이 클라이언트 컴포넌트를 임포트할 수 있음

- CSS Module에서 모듈마다 이름이 같아도 각각 다른 이름의 모듈로 명명해주므로, 모듈마다 다르게 적용됨
1) CSS Module의 역할은 모듈마다 다르게 명명하여 클래스 이름이 같더라도 다른 클래스가 됨
2) CSS 기능이 부족하며, 많이 변경하지 않고 할 수 있는 것이 SASS나 SCSS임
3) CSS Module에 SASS를 도입하여 사용하면 TailwindCSS나 Styled Compnent가 부럽지 않게 사용이 가능해짐

- 되도록 다 서버 컴포넌트로 하되, use 훅스를 사용할 때만 클라이언트 컴포넌트로 하면 됨
1) 클라이언트 컴포넌트를 꼭 지양할 필요는 없음
2) 서버 컴포넌트와 클라이언트 컴포넌트를 적재적소에 사용하거나 섞어서 사용하면 됨

- 모달 컴포넌트가 1개 이상인 경우 (2개 이상일 경우), 모달 폴더 (@)를 또 생성하면 됨
1) 이 때 내용은 달라야 됨
2) 등록은 기존 모달 컴포넌트 부분에 등록하면 됨
3) 단, 패러렐 라우터의 갯수를 스스로 제한하는 것이 좋음 -> 단, 무작정 늘어나는 것은 어려움
(하나의 폴더에서 모달을 2개 띄우도록 변경하거나, 수의 제한을 두거나 해야 함)

- 각 그룹핑을 도메인 별로 했을 때, 각 레이아웃이 달라지는 경우 기존 그룹핑에서 사용된 레이아웃은 사용해도 의미가 없어짐
1) 이런 경우는 새로 그룹핑을 한 후, 각 폴더별로 레이아웃을 생성하도록 함

- 폴더 정리용으로 그룹핑을 해도 무관함
1) 프라이빗 폴더가 그룹핑한 폴더의 상위 폴더가 되면 내부가 전부 무시가 되므로, 그룹핑을 사용해도 무관함

- 인터렉션이나 브라우저 API가 필요하면 클라이언트 컴포넌트여야 함

- 삼항 연산자보다 인터셉팅 라우트를 사용했을 때의 장점
1) 페러렐 라우트 없이 삼항연산자로 모달을 구현하면 갯수가 늘어날 때마다 힘듦
2) 주소도 하나의 데이터이자 상태임
-> 넥스트를 사용하면 주소의 상태와 state의 상태를 일치시켜야 되는 문제가 존재함
-> 패러렐 라우트를 사용하면 직접 지정하거나 연결할 필요 없이, 자동으로 지정해주거나 연결해줌
-> 데이터 연결을 자동으로 해줌

- useSearchParams(), usePathname(), useParams(), useRouter()는 자주 사용되는 훅임

- 서버에서 리다이렉트하면 인터셉트 라우터가 동작되지 않으며, 클라이언트단에서 링크를 통해 이동했을 때만 정상적으로 동작됨

- 레이아웃은 페이지가 변경되어도 고정된 부분을 기준으로 만들면 됨

- CSS에서 flex : 1을 사용하면 순서대로 배치를 하나, 각 요소 내에 flex-grow: 1을 주면 가운데 정렬이 가능함

- justify-content: space-between을 사용하면 최대한 요소 간 간격을 벌릴 수 있다

- 부모의 길이와 자식 태그의 길이가 같은 경우, 100%를 사용하면 부모의 값을 제대로 못 가져올 수 있음
1) inherit을 사용하면 부모 길이를 그대로 물려받음

- Link(a Tag)에는 되도록 inline-block을 주는 게 좋음

- 상태 값에 따라 이미지 및 색이 변하는 링크를 액티브 링크라고 함
1) 주소 값에 따라 변경될 수 있도록 연동해야 함
2) 서버 컴포넌트에선 주소의 변경에 따른 컴포넌트 속성 변경이 어려우므로 클라이언트 컴포넌트에서 진행해야 함

- useSelectedLayoutSegment 훅을 사용하면 현재 주소에 따른 라우트 위치로 자동으로 변경해줌
1) 단, 1계층 폴더만 해당됨

- useSelectedLayoutSegments 훅을 사용하면 현재 주소에 따른 라우트 위치로 자동으로 변경해줌
1) 1계층 이상 폴더에 접근 가능

- 중간에 클라이언트 컴포넌트나 서버 컴포넌트가 존재할 수 있음
1) use 훅을 사용하면 use client를 사용해야 동작됨
2) 이벤트 리스너가 있으면 use client가 사용해야 할 수도 있음

- svg 복사는 원하는 svg를 찾은 다음, 복사 - outerHTML 복사를 클릭하여 복사하면 됨

